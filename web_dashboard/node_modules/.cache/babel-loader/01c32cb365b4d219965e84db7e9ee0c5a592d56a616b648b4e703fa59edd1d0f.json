{"ast":null,"code":"// WebSocketService.js - Handles WebSocket connections for real-time data\nimport { nanoid } from 'nanoid';\nclass WebSocketService {\n  constructor() {\n    this.connections = {};\n    this.listeners = {};\n    this.baseUrl = this._getWebSocketBaseUrl();\n    this.clientId = nanoid();\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 2000; // Start with 2 seconds delay\n  }\n  _getWebSocketBaseUrl() {\n    // Convert HTTP API URL to WebSocket URL\n    // For local development, use localhost if not explicitly set\n    const apiUrl = process.env.REACT_APP_API_URL || (window.location.hostname === 'localhost' ? `${window.location.protocol}//${window.location.hostname}:8000/v1` : 'https://api.cryptotrading-platform.com/v1');\n    return apiUrl.replace(/^http/, 'ws').replace(/^https/, 'wss');\n  }\n\n  /**\n   * Connect to a specific data stream\n   * @param {string} dataType - Type of data to subscribe to (e.g., 'market', 'portfolio', 'orders')\n   * @returns {Promise} - Resolves when connection is established\n   */\n  connect(dataType) {\n    return new Promise((resolve, reject) => {\n      if (this.connections[dataType]) {\n        resolve(this.connections[dataType]);\n        return;\n      }\n      const url = `${this.baseUrl}/ws/${dataType}/${this.clientId}`;\n      const ws = new WebSocket(url);\n      ws.onopen = () => {\n        console.log(`WebSocket connected: ${dataType}`);\n        this.connections[dataType] = ws;\n        this.reconnectAttempts = 0;\n        resolve(ws);\n      };\n      ws.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          this._notifyListeners(dataType, data);\n        } catch (error) {\n          console.error('Failed to parse WebSocket message', error);\n        }\n      };\n      ws.onerror = error => {\n        console.error(`WebSocket error (${dataType}):`, error);\n        if (!this.connections[dataType]) {\n          reject(error);\n        }\n      };\n      ws.onclose = () => {\n        console.warn(`WebSocket closed: ${dataType}`);\n        delete this.connections[dataType];\n\n        // Try to reconnect if not deliberately disconnected\n        if (this.reconnectAttempts < this.maxReconnectAttempts) {\n          this.reconnectAttempts++;\n          const delay = this.reconnectDelay * Math.pow(1.5, this.reconnectAttempts - 1);\n          console.log(`Attempting to reconnect in ${delay}ms...`);\n          setTimeout(() => this.connect(dataType), delay);\n        } else {\n          console.error(`Maximum reconnection attempts reached for ${dataType}`);\n          // Notify listeners of permanent disconnect\n          this._notifyListeners(dataType, {\n            type: 'connection_error',\n            error: 'Connection lost. Please refresh the page.'\n          });\n        }\n      };\n    });\n  }\n\n  /**\n   * Disconnect from a data stream\n   * @param {string} dataType - Type of data to unsubscribe from\n   */\n  disconnect(dataType) {\n    if (this.connections[dataType]) {\n      this.connections[dataType].close();\n      delete this.connections[dataType];\n      console.log(`WebSocket disconnected: ${dataType}`);\n    }\n  }\n\n  /**\n   * Disconnect from all data streams\n   */\n  disconnectAll() {\n    Object.keys(this.connections).forEach(dataType => {\n      this.disconnect(dataType);\n    });\n    this.listeners = {};\n  }\n\n  /**\n   * Add a listener for WebSocket data\n   * @param {string} dataType - Type of data to listen for\n   * @param {Function} callback - Function to call when data is received\n   * @returns {string} - Listener ID for removal\n   */\n  addListener(dataType, callback) {\n    if (!this.listeners[dataType]) {\n      this.listeners[dataType] = {};\n    }\n    const listenerId = nanoid();\n    this.listeners[dataType][listenerId] = callback;\n    return listenerId;\n  }\n\n  /**\n   * Remove a listener\n   * @param {string} dataType - Type of data the listener was registered for\n   * @param {string} listenerId - ID of the listener to remove\n   */\n  removeListener(dataType, listenerId) {\n    if (this.listeners[dataType] && this.listeners[dataType][listenerId]) {\n      delete this.listeners[dataType][listenerId];\n    }\n  }\n\n  /**\n   * Notify all registered listeners for a data type\n   * @param {string} dataType - Type of data received\n   * @param {Object} data - Data received from WebSocket\n   * @private\n   */\n  _notifyListeners(dataType, data) {\n    if (this.listeners[dataType]) {\n      Object.values(this.listeners[dataType]).forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('Error in WebSocket listener callback', error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Get the WebSocket connection for a specific data type\n   * @param {string} dataType - Type of data to check connection for\n   * @returns {WebSocket|null} - The WebSocket connection object or null if not connected\n   */\n  getConnection(dataType) {\n    if (this.isConnected(dataType)) {\n      return this.connections[dataType];\n    }\n    return null;\n  }\n\n  /**\n   * Check if connected to a specific data stream\n   * @param {string} dataType - Type of data to check connection for\n   * @returns {boolean} - True if connected\n   */\n  isConnected(dataType) {\n    return !!this.connections[dataType] && this.connections[dataType].readyState === WebSocket.OPEN;\n  }\n}\n\n// Create singleton instance\nconst webSocketService = new WebSocketService();\nexport default webSocketService;","map":{"version":3,"names":["nanoid","WebSocketService","constructor","connections","listeners","baseUrl","_getWebSocketBaseUrl","clientId","reconnectAttempts","maxReconnectAttempts","reconnectDelay","apiUrl","process","env","REACT_APP_API_URL","window","location","hostname","protocol","replace","connect","dataType","Promise","resolve","reject","url","ws","WebSocket","onopen","console","log","onmessage","event","data","JSON","parse","_notifyListeners","error","onerror","onclose","warn","delay","Math","pow","setTimeout","type","disconnect","close","disconnectAll","Object","keys","forEach","addListener","callback","listenerId","removeListener","values","getConnection","isConnected","readyState","OPEN","webSocketService"],"sources":["/Users/antenehtessema/Desktop/botsalgo/web_dashboard/src/services/WebSocketService.js"],"sourcesContent":["// WebSocketService.js - Handles WebSocket connections for real-time data\nimport { nanoid } from 'nanoid';\n\nclass WebSocketService {\n  constructor() {\n    this.connections = {};\n    this.listeners = {};\n    this.baseUrl = this._getWebSocketBaseUrl();\n    this.clientId = nanoid();\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 2000; // Start with 2 seconds delay\n  }\n\n  _getWebSocketBaseUrl() {\n    // Convert HTTP API URL to WebSocket URL\n    // For local development, use localhost if not explicitly set\n    const apiUrl = process.env.REACT_APP_API_URL || \n      (window.location.hostname === 'localhost' ? \n        `${window.location.protocol}//${window.location.hostname}:8000/v1` : \n        'https://api.cryptotrading-platform.com/v1');\n        \n    return apiUrl.replace(/^http/, 'ws').replace(/^https/, 'wss');\n  }\n\n  /**\n   * Connect to a specific data stream\n   * @param {string} dataType - Type of data to subscribe to (e.g., 'market', 'portfolio', 'orders')\n   * @returns {Promise} - Resolves when connection is established\n   */\n  connect(dataType) {\n    return new Promise((resolve, reject) => {\n      if (this.connections[dataType]) {\n        resolve(this.connections[dataType]);\n        return;\n      }\n\n      const url = `${this.baseUrl}/ws/${dataType}/${this.clientId}`;\n      const ws = new WebSocket(url);\n\n      ws.onopen = () => {\n        console.log(`WebSocket connected: ${dataType}`);\n        this.connections[dataType] = ws;\n        this.reconnectAttempts = 0;\n        resolve(ws);\n      };\n\n      ws.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          this._notifyListeners(dataType, data);\n        } catch (error) {\n          console.error('Failed to parse WebSocket message', error);\n        }\n      };\n\n      ws.onerror = (error) => {\n        console.error(`WebSocket error (${dataType}):`, error);\n        if (!this.connections[dataType]) {\n          reject(error);\n        }\n      };\n\n      ws.onclose = () => {\n        console.warn(`WebSocket closed: ${dataType}`);\n        delete this.connections[dataType];\n        \n        // Try to reconnect if not deliberately disconnected\n        if (this.reconnectAttempts < this.maxReconnectAttempts) {\n          this.reconnectAttempts++;\n          const delay = this.reconnectDelay * Math.pow(1.5, this.reconnectAttempts - 1);\n          console.log(`Attempting to reconnect in ${delay}ms...`);\n          setTimeout(() => this.connect(dataType), delay);\n        } else {\n          console.error(`Maximum reconnection attempts reached for ${dataType}`);\n          // Notify listeners of permanent disconnect\n          this._notifyListeners(dataType, { \n            type: 'connection_error', \n            error: 'Connection lost. Please refresh the page.'\n          });\n        }\n      };\n    });\n  }\n\n  /**\n   * Disconnect from a data stream\n   * @param {string} dataType - Type of data to unsubscribe from\n   */\n  disconnect(dataType) {\n    if (this.connections[dataType]) {\n      this.connections[dataType].close();\n      delete this.connections[dataType];\n      console.log(`WebSocket disconnected: ${dataType}`);\n    }\n  }\n\n  /**\n   * Disconnect from all data streams\n   */\n  disconnectAll() {\n    Object.keys(this.connections).forEach(dataType => {\n      this.disconnect(dataType);\n    });\n    this.listeners = {};\n  }\n\n  /**\n   * Add a listener for WebSocket data\n   * @param {string} dataType - Type of data to listen for\n   * @param {Function} callback - Function to call when data is received\n   * @returns {string} - Listener ID for removal\n   */\n  addListener(dataType, callback) {\n    if (!this.listeners[dataType]) {\n      this.listeners[dataType] = {};\n    }\n    \n    const listenerId = nanoid();\n    this.listeners[dataType][listenerId] = callback;\n    return listenerId;\n  }\n\n  /**\n   * Remove a listener\n   * @param {string} dataType - Type of data the listener was registered for\n   * @param {string} listenerId - ID of the listener to remove\n   */\n  removeListener(dataType, listenerId) {\n    if (this.listeners[dataType] && this.listeners[dataType][listenerId]) {\n      delete this.listeners[dataType][listenerId];\n    }\n  }\n\n  /**\n   * Notify all registered listeners for a data type\n   * @param {string} dataType - Type of data received\n   * @param {Object} data - Data received from WebSocket\n   * @private\n   */\n  _notifyListeners(dataType, data) {\n    if (this.listeners[dataType]) {\n      Object.values(this.listeners[dataType]).forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('Error in WebSocket listener callback', error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Get the WebSocket connection for a specific data type\n   * @param {string} dataType - Type of data to check connection for\n   * @returns {WebSocket|null} - The WebSocket connection object or null if not connected\n   */\n  getConnection(dataType) {\n    if (this.isConnected(dataType)) {\n      return this.connections[dataType];\n    }\n    return null;\n  }\n\n  /**\n   * Check if connected to a specific data stream\n   * @param {string} dataType - Type of data to check connection for\n   * @returns {boolean} - True if connected\n   */\n  isConnected(dataType) {\n    return !!this.connections[dataType] && this.connections[dataType].readyState === WebSocket.OPEN;\n  }\n}\n\n// Create singleton instance\nconst webSocketService = new WebSocketService();\nexport default webSocketService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}